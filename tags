!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
LDATA	include/mlist.h	31;"	d
NULL	include/mlist.h	39;"	d
TBD_UNFINISHED	local.h	28;"	d
__fini	local.h	26;"	d
__init	local.h	25;"	d
__mlist_fini	initfini.c	/^void __fini __mlist_fini(void) {$/;"	f
__mlist_init	initfini.c	/^void __init __mlist_init(void) {$/;"	f
assert_ext	assert_np.h	47;"	d
assert_ext	assert_np.h	69;"	d
assert_ign	assert_np.h	44;"	d
assert_ign	assert_np.h	65;"	d
assert_np	assert_np.h	45;"	d
assert_np	assert_np.h	64;"	d
assert_np_h	assert_np.h	39;"	d
assert_ret	assert_np.h	46;"	d
assert_ret	assert_np.h	74;"	d
assertfail	assert_np.h	/^static inline void assertfail(char *assertstr, char *filestr, int line) {$/;"	f
cmpfunc	local.h	/^	int (*cmpfunc)(LDATA *lval, LDATA *rval);$/;"	m	struct:listheader
debuglevel	include/mlist.h	/^	int debuglevel;		  \/* Affects how much extra information is printed$/;"	m	struct:mlistmod_settings
dstrct_mlist	mlist.c	/^int dstrct_mlist(const handle_t handle) {$/;"	f
forward	mlist.c	/^static inline struct node *forward(off_t n) {$/;"	f	file:
handle_t	include/mlist.h	/^typedef uintptr_t handle_t;$/;"	t
isinit	include/mlist.h	/^	int isinit;$/;"	m	struct:mlistmod_settings
isinit	local.h	/^	int isinit;           \/* Is this module initialized? I.e. does mlist$/;"	m	struct:mlistmod_struct
libmlist_local_h	local.h	22;"	d
listheader	local.h	/^struct listheader {$/;"	s
mlist_add	mlist.c	/^struct node *mlist_add(const handle_t handle, const LDATA *data) {$/;"	f
mlist_add_first	mlist.c	/^struct node *mlist_add_first(const handle_t handle, const LDATA *data) {$/;"	f
mlist_add_last	mlist.c	/^struct node *mlist_add_last(const handle_t handle, const LDATA *data) {$/;"	f
mlist_close	mlist.c	/^int mlist_close(const handle_t handle) {$/;"	f
mlist_curr	mlist.c	/^struct node *mlist_curr(const handle_t handle) {$/;"	f
mlist_del	mlist.c	/^struct node *mlist_del(const handle_t handle) {$/;"	f
mlist_del_first	mlist.c	/^struct node *mlist_del_first(const handle_t handle) {$/;"	f
mlist_del_last	mlist.c	/^struct node *mlist_del_last(const handle_t handle) {$/;"	f
mlist_delete	mlist.c	/^int mlist_delete(const handle_t handle) {$/;"	f
mlist_dsrct	mlist.c	/^struct node *mlist_dsrct(const handle_t handle) {$/;"	f
mlist_dsrct_first	mlist.c	/^struct node *mlist_dsrct_first(const handle_t handle) {$/;"	f
mlist_dsrct_last	mlist.c	/^struct node *mlist_dsrct_last(const handle_t handle) {$/;"	f
mlist_dup	mlist.c	/^int mlist_dup(handle_t *new_hndl, handle_t orig_hndl) {$/;"	f
mlist_fini	initfini.c	/^int mlist_fini() {$/;"	f
mlist_h	include/mlist.h	22;"	d
mlist_head	mlist.c	/^struct node *mlist_head(const handle_t handle) {$/;"	f
mlist_init	initfini.c	/^int mlist_init() {$/;"	f
mlist_lseek	mlist.c	/^struct node *mlist_lseek(const handle_t handle, off_t offset, int whence) {$/;"	f
mlist_next	mlist.c	/^struct node *mlist_next(const handle_t handle) {$/;"	f
mlist_opencreate	mlist.c	/^int mlist_opencreate($/;"	f
mlist_prev	mlist.c	/^struct node *mlist_prev(const handle_t handle) {$/;"	f
mlist_search	mlist.c	/^struct node *mlist_search(const handle_t handle, const LDATA *data) {$/;"	f
mlist_tail	mlist.c	/^struct node *mlist_tail(const handle_t handle) {$/;"	f
mlistmod_data	modglobals.c	/^struct mlistmod_struct mlistmod_data = {$/;"	v	typeref:struct:mlistmod_struct
mlistmod_settings	include/mlist.h	/^struct mlistmod_settings {$/;"	s
mlistmod_settings	modglobals.c	/^struct mlistmod_settings mlistmod_settings = {$/;"	v	typeref:struct:mlistmod_settings
mlistmod_struct	local.h	/^struct mlistmod_struct {$/;"	s
mlists	local.h	/^	struct node *mlists;  \/* List-head of lists. No need to sort to find.$/;"	m	struct:mlistmod_struct	typeref:struct:mlistmod_struct::node
nelem	local.h	/^	int nelem;            \/* Current size of this list *\/$/;"	m	struct:listheader
next	include/mlist.h	/^	struct node* next;$/;"	m	struct:node	typeref:struct:node::node
nlists	local.h	/^	int nlists;           \/* Current number of lists in  list *\/$/;"	m	struct:mlistmod_struct
node	include/mlist.h	/^struct node {$/;"	s
nr_links	local.h	/^	int nr_links;         \/* if duped, will be larger than 0, note dups can$/;"	m	struct:listheader
o	local.h	/^	off_t o;              \/* Offset from start (in jumps jumps) *\/$/;"	m	struct:listheader
owner	local.h	/^	struct listheader *owner; \/* If this is a dup, will point to the$/;"	m	struct:listheader	typeref:struct:listheader::listheader
p	local.h	/^	struct node *p;	      \/* Current (file) pointer *\/$/;"	m	struct:listheader	typeref:struct:listheader::node
phead	local.h	/^	struct node *phead;   \/* List-start *\/$/;"	m	struct:listheader	typeref:struct:listheader::node
pl	include/mlist.h	/^	LDATA *pl;             \/* Payload *\/$/;"	m	struct:node
pl_sz	local.h	/^	int pl_sz;            \/* pay-load size *\/$/;"	m	struct:listheader
prev	include/mlist.h	/^	struct node* prev;$/;"	m	struct:node	typeref:struct:node::node
ptail	local.h	/^	struct node *ptail;   \/* List-end *\/$/;"	m	struct:listheader	typeref:struct:listheader::node
reverse	mlist.c	/^static inline struct node *reverse(off_t n) {$/;"	f	file:
verbose	include/mlist.h	/^	int verbose;		  \/* Additional verbosity *\/$/;"	m	struct:mlistmod_settings
